<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Etl: Expresson Transformation Language</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="file:///C:/Program%20Files/Racket/doc/local-redirect/local-redirect.js"></script><script type="text/javascript" src="file:///C:/Users/Jesse/AppData/Roaming/Racket/8.5/doc/local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Etl:<span class="mywbr"> &nbsp;</span> Expresson Transformation Language</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Rule_application_process%29" class="tocviewlink" data-pltdoc="x">Rule application process</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Conflicting_.Rules%29" class="tocviewlink" data-pltdoc="x">Conflicting Rules</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Example_programs%29" class="tocviewlink" data-pltdoc="x">Example programs</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._top%29" class="tocsubseclink" data-pltdoc="x">Etl:<span class="mywbr"> &nbsp;</span> Expresson Transformation Language</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Rule_application_process%29" class="tocsubseclink" data-pltdoc="x">Rule application process</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Conflicting_.Rules%29" class="tocsubseclink" data-pltdoc="x">Conflicting Rules</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Example_programs%29" class="tocsubseclink" data-pltdoc="x">Example programs</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._reversing_a_linked_list%29" class="tocsubseclink" data-pltdoc="x">reversing a linked list</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.S.K.I%29" class="tocsubseclink" data-pltdoc="x">SKI</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.5</span></div><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.5&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.5&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.5&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h2 x-source-module="(lib &quot;etl/scribblings/etl.scrbl&quot;)" x-source-pkg="etl" x-part-tag="&quot;top&quot;"><a name="(part._top)"></a><a name="(part._.Etl__.Expresson_.Transformation_.Language)"></a>Etl: Expresson Transformation Language</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">xSK, ported to Racket and lightly edited by Jesse P. Hamlin-Navias</p></span></div><p>Etl (pronounced like "nettle" without the n)
is an esoteric programming language for transforming expressions.
There are three data types in Etl: pairs, varaibles and operators.
Pairs are pairs of the said datatypes.
Pairs are written with parenthesies and arguments seperated by spaces.
Operators start with a ! which is followed by any sequence of alphanumeric characters.
Variables are all other sequences of alphanumeric characters.
In other implementations of etl, a wider-variety of characters may be accepted.
Here is an example:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(hello (((!0) foo) bar))</span></p></td></tr></table></p><p>Programs are written as a set of replacement rules
and a list of expressions to apply the rules to.
Here is the syntax and how they work:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rule swap (!S (a b)) -&gt; (b a)</span></p></td></tr><tr><td><p><span class="stt">(!S ((!S (a b)) c))</span></p></td></tr></table></p><p>which outputs</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(c (b a))</span></p></td></tr></table></p><p>The general syntax for rules is:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rule &lt;name&gt; &lt;pattern&gt; -&gt; &lt;replacement&gt;</span></p></td></tr></table></p><p>where &lt;name&gt; is replaced by a string of the name
of the rule (currently there is no use for the name,
one will be added in the future), and &lt;pattern&gt;
and &lt;replacement&gt; are replaced by expressions.</p><p>All variables that appear in &lt;replacement&gt; must
first appear in &lt;pattern&gt;. This behavior may not
appear in other implementations of etl. The behavior
of variables unique to &lt;replacement&gt; may be
undefined in other implementations of etl.</p><h3 x-source-module="(lib &quot;etl/scribblings/etl.scrbl&quot;)" x-source-pkg="etl" x-part-tag="&quot;Rule_application_process&quot;">1<tt>&nbsp;</tt><a name="(part._.Rule_application_process)"></a>Rule application process</h3><p>First we do a process called pattern matching
which may or may not yield a mapping between
the dummy names and actual expressions called
"bindings". For example when we match the expression
(!S (a (b c))) against the pattern (!F (a b))
we get no match because the operator !F doesn&rsquo;t
have the same name as the operator in its place
in the expression. However if we have the exprssion
(!F (x (y z))) it matches producing the following bindings:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">"a": x</span></p></td></tr><tr><td><p><span class="stt">"b": (y z)</span></p></td></tr></table></p><p>Now that we have those bindings we can produce
a different expression. That&rsquo;s what the replacement
part of the rule is for. Say that we have a rule</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rule swap (!S (a b)) -&gt; (b a)</span></p></td></tr></table></p><p>and an expression</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(!S (x (y z)))</span></p></td></tr></table></p><p>Our rule is applied recursively outside-in. So first the program generats the outermost bindings:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">"a": x,</span></p></td></tr><tr><td><p><span class="stt">"b": (y z)</span></p></td></tr></table></p><p>Then the language takes the replacement expression
and replaces every instance of "a" and "b" with the
corresponding binding. In the end of evaluation
our expression we end up with</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">((y z) x)</span></p></td></tr></table></p><h3 x-source-module="(lib &quot;etl/scribblings/etl.scrbl&quot;)" x-source-pkg="etl" x-part-tag="&quot;Conflicting_Rules&quot;">2<tt>&nbsp;</tt><a name="(part._.Conflicting_.Rules)"></a>Conflicting Rules</h3><p>If an expression matches the pattern of two different
rules, the top-most defined rule takes precedence.</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rule c1 (!C a) -&gt; (a a)</span></p></td></tr><tr><td><p><span class="stt">rule c2 (!C (a a)) -&gt; (a)</span></p></td></tr><tr><td><p><span class="stt">(!C (b b))</span></p></td></tr></table></p><p>returns</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">((b b) (b b))</span></p></td></tr></table></p><p>This behavior may not be included in other implementations
of etl. Conflicting rules may result in undefined
behavior in other implementations.</p><h3 x-source-module="(lib &quot;etl/scribblings/etl.scrbl&quot;)" x-source-pkg="etl" x-part-tag="&quot;Example_programs&quot;">3<tt>&nbsp;</tt><a name="(part._.Example_programs)"></a>Example programs</h3><h4 x-source-module="(lib &quot;etl/scribblings/etl.scrbl&quot;)" x-source-pkg="etl" x-part-tag="&quot;reversing_a_linked_list&quot;">3.1<tt>&nbsp;</tt><a name="(part._reversing_a_linked_list)"></a>reversing a linked list</h4><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rule r1 (!R ((x y) (z))) -&gt; (!R ((x) (z y)))</span></p></td></tr><tr><td><p><span class="stt">rule r2 (!R (!0 x)) -&gt; (x)</span></p></td></tr><tr><td><p><span class="stt">(!R (((((!0 a) b) c) d) !0))</span></p></td></tr></table></p><p>outputs:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">((((!0 d) c) b) a)</span></p></td></tr></table></p><h4 x-source-module="(lib &quot;etl/scribblings/etl.scrbl&quot;)" x-source-pkg="etl" x-part-tag="&quot;SKI&quot;">3.2<tt>&nbsp;</tt><a name="(part._.S.K.I)"></a>SKI</h4><p><a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">SKI_combinator_calculus</a></p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">rule S (((!S x) y) z) -&gt; ((x z) (y z))</span></p></td></tr><tr><td><p><span class="stt">rule K ((!K x) y) -&gt; (y)</span></p></td></tr><tr><td><p><span class="stt">rule I (!I y) -&gt; (y)</span></p></td></tr></table></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;8.5&quot;, &quot;../&quot;);"/></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.5&quot;);">top</a><span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;8.5&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>